{-# LANGUAGE LambdaCase, RankNTypes, DeriveFunctor #-}

module Prosidy.GenerationConcepts
  (
    -- * Generator type
    Gen (GenAwait, GenYield),

    -- * Gen combinators
    genConst, genId, genAp, genCompose,

    -- * Specific gens
    genWord8AsciiPrint

  ) where

import Data.Function (fix)

-- Char
import Data.Char (Char)
import qualified Data.Char as Char

-- Functors
import Data.Functor (Functor (fmap))
import qualified Control.Applicative
import Control.Applicative (Applicative (pure))
import Control.Monad (Monad ((>>=), return))

-- Numbers
import Data.Int (Int)
import Data.Ratio (Rational)
import Data.Word (Word8, Word64)
import Numeric.Natural (Natural)
import Prelude (Integer)
import qualified Prelude

data Gen entropy a =
      GenAwait (entropy -> Gen entropy a)
    | GenYield a (Gen entropy a)
    deriving Functor

-- | A generator that ignores its entropy and always yields the same fixed value.
genConst :: a -> Gen entropy a
genConst x = fix (GenYield x)

-- | A generator that simply yields its entropy values unmodified.
genId :: Gen a a
genId = fix (\g -> GenAwait (\e -> GenYield e g))

-- | Function application within the 'Gen' context.
genAp :: Gen entropy (a -> b) -> Gen entropy a -> Gen entropy b
genAp (GenYield f genF) (GenYield x genX) = GenYield (f x) (genAp genF genX)
genAp (GenAwait toGenF) genX = GenAwait (\e -> let genF = toGenF e in genAp genF genX)
genAp genF (GenAwait toGenX) = GenAwait (\e -> let genX = toGenX e in genAp genF genX)

-- | Arrow composition of generators. @'genCompose' f g@ uses the values generated by @f@ as the entropy for @g@.
genCompose :: Gen a b -> Gen b c -> Gen a c
genCompose f (GenYield c g) = GenYield c (genCompose f g)
genCompose (GenYield b f) (GenAwait toC) = genCompose f (toC b)
genCompose (GenAwait toB) g = GenAwait (\a -> genCompose (toB a) g)

genWord8AsciiPrint :: Gen Word8 Char
genWord8AsciiPrint =
    fix (\g -> GenAwait (\b -> let c = word8Char b in
        if Char.isPrint c then GenYield c g else g))

word8Int :: Word8 -> Int
word8Int = Prelude.fromIntegral

word8Char :: Word8 -> Char
word8Char b = Char.chr (word8Int b)
